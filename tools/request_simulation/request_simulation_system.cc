// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "tools/request_simulation/request_simulation_system.h"

#include <algorithm>
#include <string>
#include <utility>
#include <vector>

#include "glog/logging.h"
#include "grpcpp/grpcpp.h"
#include "public/query/get_values.grpc.pb.h"
#include "tools/request_simulation/request/raw_request.pb.h"
#include "tools/request_simulation/request_generation_util.h"

ABSL_FLAG(std::string, server_address, "",
          "The address of the server under test,"
          "in format demo.kv-server.your-domain.example");
ABSL_FLAG(std::string, server_method, "/kv_server.v2.KeyValueService/GetValues",
          "The api name of the server under test");
ABSL_FLAG(int64_t, rps, 1000, "Requests per second sent to the server");
ABSL_FLAG(int, concurrency, 10,
          "Number of concurrent requests sent to the server,"
          "this number will be limited by the maximum concurrent threads"
          "supported by state of the machine");
ABSL_FLAG(absl::Duration, request_timeout, absl::Seconds(5),
          "The timeout duration for getting response for the request");
ABSL_FLAG(int64_t, synthetic_requests_fill_qps, 3000,
          "The per second rate of synthetic requests generated by the "
          "simulation system");
ABSL_FLAG(int, number_of_keys_per_request, 1,
          "The number of keys in one synthetic request");
ABSL_FLAG(int, key_size, 20, "The size of the key in bytes");
ABSL_FLAG(absl::Duration, rate_limiter_permits_acquire_timeout,
          absl::Seconds(10),
          "The timeout duration for acquiring permits from rate limiter");
ABSL_FLAG(
    int, rate_limiter_initial_permits, 0,
    "The initial number of permits available when the rate limiter is created");
ABSL_FLAG(int64_t, message_queue_max_capacity, 10000000,
          "The maximum number of messages held by the message queue");
ABSL_FLAG(kv_server::GrpcAuthenticationMode, server_auth_mode,
          kv_server::GrpcAuthenticationMode::kSsl,
          "The server authentication mode");

namespace kv_server {

using privacy_sandbox::server_common::SteadyClock;

std::unique_ptr<RateLimiter> RequestSimulationSystem::CreateRateLimiter(
    int64_t per_second_rate) {
  return std::make_unique<RateLimiter>(
      0, per_second_rate, steady_clock_, *sleep_for_,
      absl::GetFlag(FLAGS_rate_limiter_permits_acquire_timeout));
}

absl::Status RequestSimulationSystem::InitAndStart() {
  if (auto status = Init(); !status.ok()) {
    return status;
  }
  return Start();
}

// TODO(b/289240702) When running on non-local environment,
// populate parameters either from a config file on blob storage
// or from parameter store.
absl::Status RequestSimulationSystem::Init() {
  server_address_ = absl::GetFlag(FLAGS_server_address);
  server_method_ = absl::GetFlag(FLAGS_server_method);
  concurrent_number_of_requests_ = absl::GetFlag(FLAGS_concurrency);
  synthetic_request_gen_option_.number_of_keys_per_request =
      absl::GetFlag(FLAGS_number_of_keys_per_request);
  synthetic_request_gen_option_.key_size_in_bytes =
      absl::GetFlag(FLAGS_key_size);
  synthetic_request_generator_rate_limiter_ =
      CreateRateLimiter(absl::GetFlag(FLAGS_synthetic_requests_fill_qps));
  grpc_request_rate_limiter_ = CreateRateLimiter(absl::GetFlag(FLAGS_rps));
  message_queue_ = absl::make_unique<MessageQueue>(
      absl::GetFlag(FLAGS_message_queue_max_capacity));
  synthetic_request_generator_ = std::make_unique<SyntheticRequestGenerator>(
      *message_queue_, *synthetic_request_generator_rate_limiter_, [this]() {
        const auto keys = kv_server::GenerateRandomKeys(
            synthetic_request_gen_option_.number_of_keys_per_request,
            synthetic_request_gen_option_.key_size_in_bytes);
        return kv_server::CreateKVDSPRequestBodyInJson(keys);
      });
  if (auto status = InitializeGrpcClientWorkers(); !status.ok()) {
    return status;
  }
  LOG(INFO) << "Request simulation system is initialized,"
               "target server address is "
            << server_address_ << " and server method is " << server_method_;
  return absl::OkStatus();
}
absl::Status RequestSimulationSystem::InitializeGrpcClientWorkers() {
  if (server_address_.empty()) {
    return absl::FailedPreconditionError("Server address cannot be empty");
  }
  int num_of_workers = std::min(concurrent_number_of_requests_,
                                (int)std::thread::hardware_concurrency());
  if (num_of_workers < 1) {
    return absl::FailedPreconditionError(
        "Could not initialize grpc client worker,"
        "no thread is available to use");
  }
  auto request_converter = [](const std::string& request_body) {
    RawRequest request;
    request.mutable_raw_body()->set_data(request_body);
    return request;
  };

  for (int i = 0; i < num_of_workers; ++i) {
    auto channel = channel_creation_fn_(server_address_,
                                        absl::GetFlag(FLAGS_server_auth_mode));
    auto worker =
        std::make_unique<ClientWorker<RawRequest, google::api::HttpBody>>(
            i, channel, server_method_, absl::Seconds(1), request_converter,
            *message_queue_, *grpc_request_rate_limiter_);
    grpc_client_workers_.push_back(std::move(worker));
  }
  return absl::OkStatus();
}

absl::Status RequestSimulationSystem::Start() {
  LOG(INFO) << "Starting synthetic request generator";
  if (auto status = synthetic_request_generator_->Start(); !status.ok()) {
    return status;
  }
  LOG(INFO) << "Starting " << grpc_client_workers_.size() << " client workers";
  for (const auto& worker : grpc_client_workers_) {
    if (auto status = worker->Start(); !status.ok()) {
      return status;
    }
  }
  is_running = true;
  LOG(INFO) << "Request simulation system is started!";
  return absl::OkStatus();
}
absl::Status RequestSimulationSystem::Stop() {
  LOG(INFO) << "Stopping synthetic request generator";
  if (auto status = synthetic_request_generator_->Stop(); !status.ok()) {
    return status;
  }
  LOG(INFO) << "Stopping client workers";
  for (const auto& worker : grpc_client_workers_) {
    if (auto status = worker->Stop(); !status.ok()) {
      return status;
    }
  }
  LOG(INFO) << "Request simulation system is stopped!";
  is_running = false;
  return absl::OkStatus();
}

bool RequestSimulationSystem::IsRunning() const { return is_running; }

}  // namespace kv_server
